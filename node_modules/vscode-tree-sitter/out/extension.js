"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = require("vscode");
const Parser = require("web-tree-sitter");
const path = require("path");
const scopes = require("./scopes");
// Parse of all visible documents
const trees = new Map();
function tree(uri) {
    return trees.get(uri.toString());
}
exports.tree = tree;
// Create decoration types from scopes lazily
const decorationCache = new Map();
const warnedScopes = new Set();
function decoration(scope) {
    // If we've already created a decoration for `scope`, use it
    if (decorationCache.has(scope)) {
        return decorationCache.get(scope);
    }
    // If `scope` is defined in the current theme, create a decoration for it
    const textmate = scopes.find(scope);
    if (textmate) {
        const decoration = createDecorationFromTextmate(textmate);
        decorationCache.set(scope, decoration);
        return decoration;
    }
    // Otherwise, give up, there is no color available for this scope
    if (!warnedScopes.has(scope)) {
        console.warn(scope, 'was not found in the current theme');
        warnedScopes.add(scope);
    }
    return undefined;
}
exports.decoration = decoration;
function createDecorationFromTextmate(themeStyle) {
    let options = {};
    options.rangeBehavior = vscode.DecorationRangeBehavior.OpenOpen;
    if (themeStyle.foreground) {
        options.color = themeStyle.foreground;
    }
    if (themeStyle.background) {
        options.backgroundColor = themeStyle.background;
    }
    if (themeStyle.fontStyle) {
        let parts = themeStyle.fontStyle.split(" ");
        parts.forEach((part) => {
            switch (part) {
                case "italic":
                    options.fontStyle = "italic";
                    break;
                case "bold":
                    options.fontWeight = "bold";
                    break;
                case "underline":
                    options.textDecoration = "underline";
                    break;
                default:
                    break;
            }
        });
    }
    return vscode.window.createTextEditorDecorationType(options);
}
// Load styles from the current active theme
function loadStyles() {
    return __awaiter(this, void 0, void 0, function* () {
        yield scopes.load();
        // Clear old styles
        for (const style of decorationCache.values()) {
            style.dispose();
        }
        decorationCache.clear();
    });
}
// For some reason this crashes if we put it inside activate
const initParser = Parser.init(); // TODO this isn't a field, suppress package member coloring like Go
// Called when the extension is first activated by user opening a file with the appropriate language
function activate(context, languages) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log("Activating tree-sitter...");
        function open(editor) {
            return __awaiter(this, void 0, void 0, function* () {
                const language = languages[editor.document.languageId];
                if (language == null)
                    return;
                if (language.parser == null) {
                    const wasm = path.relative(process.cwd(), language.wasm);
                    const lang = yield Parser.Language.load(wasm);
                    const parser = new Parser();
                    parser.setLanguage(lang);
                    language.parser = parser;
                }
                const t = language.parser.parse(editor.document.getText()); // TODO don't use getText, use Parser.Input
                trees.set(editor.document.uri.toString(), t);
            });
        }
        // NOTE: if you make this an async function, it seems to cause edit anomalies
        function edit(edit) {
            const language = languages[edit.document.languageId];
            if (language == null || language.parser == null)
                return;
            updateTree(language.parser, edit);
        }
        function updateTree(parser, edit) {
            if (edit.contentChanges.length == 0)
                return;
            const old = trees.get(edit.document.uri.toString());
            for (const e of edit.contentChanges) {
                const startIndex = e.rangeOffset;
                const oldEndIndex = e.rangeOffset + e.rangeLength;
                const newEndIndex = e.rangeOffset + e.text.length;
                const startPos = edit.document.positionAt(startIndex);
                const oldEndPos = edit.document.positionAt(oldEndIndex);
                const newEndPos = edit.document.positionAt(newEndIndex);
                const startPosition = asPoint(startPos);
                const oldEndPosition = asPoint(oldEndPos);
                const newEndPosition = asPoint(newEndPos);
                const delta = { startIndex, oldEndIndex, newEndIndex, startPosition, oldEndPosition, newEndPosition };
                old.edit(delta);
            }
            const t = parser.parse(edit.document.getText(), old); // TODO don't use getText, use Parser.Input
            trees.set(edit.document.uri.toString(), t);
        }
        function asPoint(pos) {
            return { row: pos.line, column: pos.character };
        }
        function close(doc) {
            trees.delete(doc.uri.toString());
        }
        function openAll() {
            return __awaiter(this, void 0, void 0, function* () {
                for (const editor of vscode.window.visibleTextEditors) {
                    yield open(editor);
                }
            });
        }
        // Load active color theme
        function onChangeConfiguration(event) {
            return __awaiter(this, void 0, void 0, function* () {
                let colorizationNeedsReload = event.affectsConfiguration("workbench.colorTheme")
                    || event.affectsConfiguration("editor.tokenColorCustomizations");
                if (colorizationNeedsReload) {
                    yield loadStyles();
                }
            });
        }
        context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(onChangeConfiguration));
        context.subscriptions.push(vscode.window.onDidChangeVisibleTextEditors(openAll));
        context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(edit));
        context.subscriptions.push(vscode.workspace.onDidCloseTextDocument(close));
        // Don't wait for the initial color, it takes too long to inspect the themes and causes VSCode extension host to hang
        yield loadStyles();
        yield initParser;
        yield openAll();
    });
}
exports.activate = activate;
function range(x) {
    return new vscode.Range(x.startPosition.row, x.startPosition.column, x.endPosition.row, x.endPosition.column);
}
exports.range = range;
// this method is called when your extension is deactivated
function deactivate() { }
exports.deactivate = deactivate;
//# sourceMappingURL=extension.js.map